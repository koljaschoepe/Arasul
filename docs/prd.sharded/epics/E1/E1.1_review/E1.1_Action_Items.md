# Story E1.1 â€“ Action Items & Prod-Readiness Checklist

**Status:** ðŸ”´ **BLOCKER fÃ¼r Produktion**  
**Ziel:** Prod-Readiness in 2-3 Tagen  
**Owner:** Backend-Team

---

## ðŸ”´ PrioritÃ¤t 1: Kritische Security-HÃ¤rtungen (MUSS)

### 1. Rate-Limiting & Brute-Force-Schutz
**Warum:** Ohne Rate-Limiting sind Brute-Force-Angriffe auf Login mÃ¶glich  
**Risiko:** Kritisch  
**Aufwand:** ~2h

```bash
npm install express-rate-limit
```

**Implementierung in `server.ts`:**
```typescript
import rateLimit from 'express-rate-limit';

// General API Rate Limit
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 min
  max: 100,
  message: 'Zu viele Anfragen, bitte spÃ¤ter erneut versuchen'
});

// Strict Auth Rate Limit
const authLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 min
  max: 5, // 5 Fehlversuche
  skipSuccessfulRequests: true,
  message: 'Account temporÃ¤r gesperrt nach zu vielen Fehlversuchen'
});

app.use('/auth/login', authLimiter);
app.use('/api/', apiLimiter);
```

**Checklist:**
- [ ] `express-rate-limit` installiert
- [ ] Auth-Limiter konfiguriert (5 Fehlversuche/10min)
- [ ] API-Limiter konfiguriert (100 req/15min)
- [ ] Test: 6. Login-Versuch wird blockiert
- [ ] Audit-Event bei Rate-Limit-Trigger

---

### 2. Session-HÃ¤rtung
**Warum:** `secure: false` erlaubt Session-Hijacking Ã¼ber unverschlÃ¼sselte Verbindungen  
**Risiko:** Hoch  
**Aufwand:** ~1h

**Implementierung in `server.ts`:**
```typescript
app.use(session({
  secret: process.env.SESSION_SECRET!, // Env-Variable erforderlich!
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // true in Prod
    httpOnly: true,
    sameSite: 'strict',
    maxAge: 15 * 60 * 1000 // Idle-Timeout: 15 min
  }
}));
```

**Session-Timeout-Middleware:**
```typescript
// middlewares/sessionTimeout.ts
export function sessionTimeout(req: Request, res: Response, next: NextFunction) {
  const session = req.session as any;
  if (session.user) {
    // Absolute Timeout (8h)
    if (!session.createdAt) session.createdAt = Date.now();
    if (session.createdAt + 8*60*60*1000 < Date.now()) {
      req.session.destroy(() => {});
      return res.status(401).json({ error: 'Session abgelaufen' });
    }
    
    // Idle Timeout (15min)
    if (session.lastActivity && session.lastActivity + 15*60*1000 < Date.now()) {
      req.session.destroy(() => {});
      return res.status(401).json({ error: 'Session inaktiv' });
    }
    
    session.lastActivity = Date.now();
  }
  next();
}
```

**Checklist:**
- [ ] `.env`: `SESSION_SECRET` generiert (32+ Zeichen, kryptografisch sicher)
- [ ] Cookie-Flags korrekt: `secure=true`, `httpOnly`, `sameSite=strict`
- [ ] Idle-Timeout: 15 Minuten
- [ ] Absolute-Timeout: 8 Stunden
- [ ] Test: Session wird nach 15min InaktivitÃ¤t ungÃ¼ltig
- [ ] Test: Session wird nach 8h ungÃ¼ltig

---

### 3. 403-Audit-Events in RBAC-Middleware
**Warum:** Angriffsversuche (403) werden aktuell nicht geloggt (widerspricht Shard 03)  
**Risiko:** Mittel  
**Aufwand:** ~30min

**Implementierung in `middlewares/rbac.ts`:**
```typescript
import { writeAudit } from '../services/auditService.js';

export function requireRoles(required: string[]) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const user = (req.session as any)?.user as { id: string; roles: string[] } | undefined;
    if (!user) return res.status(401).json({ error: 'unauthenticated' });
    const has = required.some(r => user.roles.includes(r));
    if (!has) {
      // Audit-Event schreiben
      await writeAudit({
        actorUserId: user.id,
        entityType: 'Access',
        action: 'DENIED',
        after: { 
          endpoint: req.path, 
          method: req.method, 
          ip: req.ip,
          requiredRoles: required,
          userRoles: user.roles
        }
      });
      return res.status(403).json({ error: 'forbidden' });
    }
    next();
  };
}
```

**Checklist:**
- [ ] `writeAudit` bei 403 aufgerufen
- [ ] Audit-Event enthÃ¤lt: Endpunkt, Methode, IP, erforderliche Rollen
- [ ] Test: Nach 403 ist Audit-Event in DB vorhanden
- [ ] DB-Query: `SELECT * FROM AuditEvent WHERE action='DENIED'` funktioniert

---

### 4. CSRF-Schutz fÃ¼r Admin-Formulare
**Warum:** Admin-UI ist anfÃ¤llig fÃ¼r Cross-Site Request Forgery  
**Risiko:** Hoch  
**Aufwand:** ~2h

```bash
npm install csurf
```

**Implementierung in `server.ts`:**
```typescript
import csrf from 'csurf';

const csrfProtection = csrf({ cookie: true });

// Nur fÃ¼r Admin-UI-Routen (nicht fÃ¼r API-JSON-Endpunkte)
app.use('/admin', csrfProtection);

// Token in Views verfÃ¼gbar machen
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken ? req.csrfToken() : null;
  next();
});
```

**In EJS-Templates:**
```html
<form method="POST">
  <input type="hidden" name="_csrf" value="<%= csrfToken %>">
  <!-- Formularfelder -->
</form>
```

**Checklist:**
- [ ] `csurf` installiert
- [ ] CSRF-Token in alle Admin-Formulare eingefÃ¼gt
- [ ] Test: POST ohne Token wird mit 403 abgewiesen
- [ ] Test: POST mit gÃ¼ltigem Token funktioniert

---

### 5. Passwort-Policy-Validierung
**Warum:** Aktuell sind schwache PasswÃ¶rter erlaubt (widerspricht Shard 03)  
**Risiko:** Mittel  
**Aufwand:** ~1h

```bash
npm install zxcvbn
```

**Implementierung in `services/authService.ts`:**
```typescript
import zxcvbn from 'zxcvbn';

const COMMON_PASSWORDS = ['password', 'admin123', '123456', 'qwerty']; // erweitern

export function validatePasswordPolicy(password: string, email: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // MindestlÃ¤nge 12
  if (password.length < 12) {
    errors.push('Passwort muss mindestens 12 Zeichen lang sein');
  }
  
  // Zxcvbn-StÃ¤rke â‰¥ 3
  const result = zxcvbn(password, [email]);
  if (result.score < 3) {
    errors.push('Passwort ist zu schwach. Verwenden Sie eine Kombination aus Buchstaben, Zahlen und Sonderzeichen.');
  }
  
  // Blacklist
  if (COMMON_PASSWORDS.some(p => password.toLowerCase().includes(p))) {
    errors.push('Passwort ist zu hÃ¤ufig verwendet. WÃ¤hlen Sie ein sichereres Passwort.');
  }
  
  return { valid: errors.length === 0, errors };
}
```

**In `routes/users.ts` und `routes/auth.ts`:**
```typescript
const validation = validatePasswordPolicy(password, email);
if (!validation.valid) {
  return res.status(400).json({ errors: validation.errors });
}
```

**Checklist:**
- [ ] `zxcvbn` installiert
- [ ] Validierung in User-Create implementiert
- [ ] Validierung in Password-Reset implementiert
- [ ] Test: Passwort < 12 Zeichen wird abgelehnt
- [ ] Test: Passwort mit Zxcvbn-Score < 3 wird abgelehnt
- [ ] Test: Blacklist-Passwort wird abgelehnt

---

### 6. Argon2id statt bcrypt
**Warum:** Shard 03 fordert explizit Argon2id (moderner, resistenter gegen GPU-Angriffe)  
**Risiko:** Niedrig (bcrypt ist OK, aber nicht Spec-konform)  
**Aufwand:** ~1h

```bash
npm install argon2
```

**Implementierung in `services/authService.ts`:**
```typescript
import argon2 from 'argon2';

export async function hashPassword(plain: string) {
  return argon2.hash(plain, { 
    type: argon2.argon2id,
    memoryCost: 2 ** 16, // 64 MB
    timeCost: 3,
    parallelism: 1
  });
}

export async function verifyPassword(plain: string, hash: string) {
  try {
    return await argon2.verify(hash, plain);
  } catch {
    return false;
  }
}
```

**Migration-Strategie:**
- Neue PasswÃ¶rter werden mit Argon2id gehasht
- Bestehende bcrypt-Hashes bleiben gÃ¼ltig (Hybrid-Verifikation)
- Beim nÃ¤chsten Login wird Hash automatisch auf Argon2id migriert

**Checklist:**
- [ ] `argon2` installiert
- [ ] `hashPassword` auf Argon2id umgestellt
- [ ] `verifyPassword` unterstÃ¼tzt bcrypt-Hashes (Fallback)
- [ ] Test: Neues Passwort wird mit Argon2id gehasht
- [ ] Test: Alte bcrypt-Hashes funktionieren weiterhin
- [ ] Migration-Script fÃ¼r bestehende PasswÃ¶rter (optional)

---

### 7. SESSION_SECRET aus Environment
**Warum:** Hardcodierter Default `'change-me'` ist inakzeptabel fÃ¼r Produktion  
**Risiko:** Kritisch  
**Aufwand:** ~15min

**`.env` (nicht committen!):**
```env
SESSION_SECRET=<generiert mit: openssl rand -base64 32>
NODE_ENV=production
DATABASE_URL=file:./prod.db
```

**In `server.ts`:**
```typescript
if (!process.env.SESSION_SECRET) {
  throw new Error('SESSION_SECRET muss in .env gesetzt sein');
}

app.use(session({
  secret: process.env.SESSION_SECRET,
  // ...
}));
```

**Checklist:**
- [ ] `.env.example` mit Platzhalter erstellt
- [ ] `.env` in `.gitignore`
- [ ] SESSION_SECRET generiert (32+ Zeichen)
- [ ] Server wirft Fehler, wenn SESSION_SECRET fehlt
- [ ] Deployment-Docs aktualisiert (Env-Variable setzen)

---

## ðŸŸ  PrioritÃ¤t 2: Wichtige Features (Sollte)

### 8. Recovery-Codes fÃ¼r 2FA
**Warum:** Benutzer kÃ¶nnen ausgesperrt werden, wenn TOTP-GerÃ¤t verloren geht  
**Aufwand:** ~2h

**Schema-Erweiterung `schema.prisma`:**
```prisma
model User {
  // ...
  recoveryCodes String[] // Array von gehashten Codes
}
```

**Implementierung in `routes/auth.ts`:**
```typescript
import crypto from 'crypto';

function generateRecoveryCodes(count = 10): string[] {
  return Array.from({ length: count }, () => 
    crypto.randomBytes(4).toString('hex').toUpperCase()
  );
}

router.post('/enable-2fa', async (req, res) => {
  // ... existing code ...
  
  const recoveryCodes = generateRecoveryCodes();
  const hashedCodes = await Promise.all(
    recoveryCodes.map(code => hashPassword(code))
  );
  
  await prisma.user.update({
    where: { id: actor.id },
    data: { 
      twoFactorSecret: secret, 
      twoFactorEnabled: true,
      recoveryCodes: hashedCodes
    }
  });
  
  res.json({ secret, recoveryCodes }); // Einmalige Anzeige!
});

router.post('/login-recovery', async (req, res) => {
  const { email, password, recoveryCode } = req.body;
  const user = await getUserWithRolesByEmail(email);
  // ... password check ...
  
  // Recovery-Code prÃ¼fen
  for (const hashedCode of user.recoveryCodes || []) {
    if (await verifyPassword(recoveryCode, hashedCode)) {
      // Code verbrauchen (aus Array entfernen)
      const newCodes = user.recoveryCodes.filter(c => c !== hashedCode);
      await prisma.user.update({
        where: { id: user.id },
        data: { recoveryCodes: newCodes }
      });
      
      // Session erstellen
      // ... existing login logic ...
      return res.json({ ok: true });
    }
  }
  
  return res.status(401).json({ error: 'UngÃ¼ltiger Recovery-Code' });
});
```

**Checklist:**
- [ ] Schema migriert (`npx prisma migrate dev`)
- [ ] 10 Recovery-Codes bei 2FA-Aktivierung generiert
- [ ] Codes werden gehashed gespeichert
- [ ] Codes werden nur einmalig angezeigt
- [ ] UI: Download-Button fÃ¼r Codes (TXT-Datei)
- [ ] Recovery-Login-Endpunkt funktioniert
- [ ] Verwendeter Code wird entfernt
- [ ] Test: Login mit Recovery-Code erfolgreich
- [ ] Test: Zweite Verwendung desselben Codes schlÃ¤gt fehl

---

### 9. QR-Code-Generierung fÃ¼r TOTP
**Warum:** Manuelle Secret-Eingabe ist fehleranfÃ¤llig, QR-Code ist Standard  
**Aufwand:** ~1h

```bash
npm install qrcode
```

**Implementierung:**
```typescript
import QRCode from 'qrcode';

router.post('/enable-2fa', async (req, res) => {
  // ... existing code ...
  
  const user = await prisma.user.findUnique({ where: { id: actor.id } });
  const otpauthUrl = authenticator.keyuri(
    user!.email, 
    'Jetson Dashboard', 
    secret
  );
  
  const qrCodeDataUrl = await QRCode.toDataURL(otpauthUrl);
  
  res.json({ secret, qrCodeDataUrl, recoveryCodes });
});
```

**In Admin-UI (`views/admin/users.ejs`):**
```html
<img src="<%= qrCodeDataUrl %>" alt="TOTP QR Code">
<p>Oder manuell: <%= secret %></p>
```

**Checklist:**
- [ ] `qrcode` installiert
- [ ] QR-Code-URL generiert
- [ ] UI zeigt QR-Code an
- [ ] Test: QR-Code scannen mit Authenticator-App funktioniert

---

### 10. Admin-Handbuch & API-Dokumentation
**Warum:** Betrieb ohne Dokumentation ist fehleranfÃ¤llig  
**Aufwand:** ~3h

**Zu erstellen:**

1. **Admin-Handbuch (`docs/admin-guide.md`):**
   - Benutzer anlegen, bearbeiten, deaktivieren
   - Rollen zuweisen/entziehen
   - 2FA aktivieren/deaktivieren
   - Recovery-Codes verwenden
   - Passwort-Reset durchfÃ¼hren
   - Audit-Logs einsehen

2. **API-Referenz (`docs/api-reference.md`):**
   - Alle Endpunkte mit Beispielen
   - Request/Response-Schemas
   - RBAC-Anforderungen
   - Fehler-Codes

3. **Deployment-Guide (`docs/deployment.md`):**
   - Environment-Variablen
   - TLS/Caddy-Konfiguration
   - Datenbank-Migrationen
   - Backup-Strategie

**Checklist:**
- [ ] Admin-Handbuch geschrieben
- [ ] API-Referenz mit Beispielen
- [ ] Deployment-Guide mit Env-Variablen
- [ ] Screenshots fÃ¼r UI-Flows
- [ ] Troubleshooting-Sektion

---

## ðŸŸ¢ PrioritÃ¤t 3: UX-Verbesserungen (Kann)

### 11. Such-/Filter-FunktionalitÃ¤t in UI
**Aufwand:** ~2h

**API-Erweiterung:**
```typescript
router.get('/', requireRoles(['admin']), async (req, res) => {
  const { query, role, active, limit = 50, offset = 0 } = req.query;
  
  const users = await prisma.user.findMany({
    where: {
      AND: [
        query ? {
          OR: [
            { name: { contains: String(query) } },
            { email: { contains: String(query) } }
          ]
        } : {},
        active !== undefined ? { isActive: active === 'true' } : {},
        role ? { roles: { some: { role: { name: String(role) } } } } : {}
      ]
    },
    include: { roles: { include: { role: true } } },
    take: Number(limit),
    skip: Number(offset)
  });
  
  res.json(users);
});
```

**Checklist:**
- [ ] Such-Feld in UI
- [ ] Filter-Dropdowns (Rolle, Status)
- [ ] Pagination-Controls
- [ ] Backend-Endpoints angepasst

---

## Manuelle Test-Checkliste (nach P1-Implementierung)

### Admin-UI
- [ ] Login mit Admin erfolgreich
- [ ] Benutzer anlegen â†’ erscheint in Liste
- [ ] Benutzer bearbeiten â†’ Ã„nderung sichtbar
- [ ] Benutzer deaktivieren â†’ Status Ã¤ndert sich
- [ ] Rolle zuweisen â†’ Badge erscheint
- [ ] 2FA aktivieren â†’ QR-Code erscheint
- [ ] Recovery-Codes anzeigen â†’ Download funktioniert

### RBAC
- [ ] Non-Admin-User: `/users` â†’ 403
- [ ] Vendor-Readonly: `/admin/services` â†’ 403
- [ ] Admin: Alle Endpunkte â†’ 200/201

### Security
- [ ] 6. Login-Versuch â†’ Rate-Limit-Fehler
- [ ] Session nach 15min Idle â†’ 401
- [ ] Session nach 8h â†’ 401
- [ ] POST ohne CSRF-Token â†’ 403
- [ ] Schwaches Passwort (z.B. "admin") â†’ 400

### Audit
- [ ] User-Create â†’ Audit-Event in DB
- [ ] 403-Fehler â†’ Audit-Event mit "DENIED"
- [ ] 2FA-Enable â†’ Audit-Event

---

## Definition of Done (Ã¼berarbeitet)

- [x] Benutzer-CRUD vollstÃ¤ndig
- [x] Rollen-CRUD vollstÃ¤ndig
- [x] RBAC wirksam (403 getestet)
- [x] 2FA optional aktivierbar, TOTP-Login
- [x] Audit-Events bei allen Ã„nderungen
- [ ] **Rate-Limiting implementiert** (P1)
- [ ] **Session-HÃ¤rtung** (P1)
- [ ] **CSRF-Schutz** (P1)
- [ ] **Passwort-Policy** (P1)
- [ ] **403-Audit-Events** (P1)
- [ ] **Argon2id** (P1)
- [ ] Recovery-Codes (P2)
- [ ] QR-Code-Generierung (P2)
- [ ] **Dokumentation** (P2)
- [ ] Manuelle Tests bestanden
- [ ] Security-Review nach HÃ¤rtung

---

## Timeline

**Woche 1 (Tag 1-3): P1-Implementierung**
- Tag 1: Rate-Limiting, Session-HÃ¤rtung, 403-Audit
- Tag 2: CSRF, Passwort-Policy, Argon2id
- Tag 3: Manuelle Tests, Bug-Fixes

**Woche 2 (Tag 4-6): P2-Implementierung**
- Tag 4: Recovery-Codes, QR-Codes
- Tag 5: Dokumentation schreiben
- Tag 6: Finaler Review, Prod-Deployment

---

**Aktueller Status:** ðŸ”´ 7/14 P1-Items offen  
**Ziel:** âœ… Alle P1-Items in 2-3 Tagen  
**NÃ¤chster Milestone:** Security-Review nach P1-HÃ¤rtung

