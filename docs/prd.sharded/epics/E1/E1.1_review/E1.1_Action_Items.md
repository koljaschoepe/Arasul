# Story E1.1 ‚Äì Action Items & Prod-Readiness Checklist

**Status:** üî¥ **BLOCKER f√ºr Produktion**  
**Ziel:** Prod-Readiness in 2-3 Tagen  
**Owner:** Backend-Team

---

## üî¥ Priorit√§t 1: Kritische Security-H√§rtungen (MUSS)

### 1. Rate-Limiting & Brute-Force-Schutz
**Warum:** Ohne Rate-Limiting sind Brute-Force-Angriffe auf Login m√∂glich  
**Risiko:** Kritisch  
**Aufwand:** ~2h

```bash
npm install express-rate-limit
```

**Implementierung in `server.ts`:**
```typescript
import rateLimit from 'express-rate-limit';

// General API Rate Limit
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 min
  max: 100,
  message: 'Zu viele Anfragen, bitte sp√§ter erneut versuchen'
});

// Strict Auth Rate Limit
const authLimiter = rateLimit({
  windowMs: 10 * 60 * 1000, // 10 min
  max: 5, // 5 Fehlversuche
  skipSuccessfulRequests: true,
  message: 'Account tempor√§r gesperrt nach zu vielen Fehlversuchen'
});

app.use('/auth/login', authLimiter);
app.use('/api/', apiLimiter);
```

**Checklist:**
- [ ] `express-rate-limit` installiert
- [ ] Auth-Limiter konfiguriert (5 Fehlversuche/10min)
- [ ] API-Limiter konfiguriert (100 req/15min)
- [ ] Test: 6. Login-Versuch wird blockiert
- [ ] Audit-Event bei Rate-Limit-Trigger

---

### 2. Session-H√§rtung
**Warum:** `secure: false` erlaubt Session-Hijacking √ºber unverschl√ºsselte Verbindungen  
**Risiko:** Hoch  
**Aufwand:** ~1h

**Implementierung in `server.ts`:**
```typescript
app.use(session({
  secret: process.env.SESSION_SECRET!, // Env-Variable erforderlich!
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production', // true in Prod
    httpOnly: true,
    sameSite: 'strict',
    maxAge: 15 * 60 * 1000 // Idle-Timeout: 15 min
  }
}));
```

**Session-Timeout-Middleware:**
```typescript
// middlewares/sessionTimeout.ts
export function sessionTimeout(req: Request, res: Response, next: NextFunction) {
  const session = req.session as any;
  if (session.user) {
    // Absolute Timeout (8h)
    if (!session.createdAt) session.createdAt = Date.now();
    if (session.createdAt + 8*60*60*1000 < Date.now()) {
      req.session.destroy(() => {});
      return res.status(401).json({ error: 'Session abgelaufen' });
    }
    
    // Idle Timeout (15min)
    if (session.lastActivity && session.lastActivity + 15*60*1000 < Date.now()) {
      req.session.destroy(() => {});
      return res.status(401).json({ error: 'Session inaktiv' });
    }
    
    session.lastActivity = Date.now();
  }
  next();
}
```

**Checklist:**
- [ ] `.env`: `SESSION_SECRET` generiert (32+ Zeichen, kryptografisch sicher)
- [ ] Cookie-Flags korrekt: `secure=true`, `httpOnly`, `sameSite=strict`
- [ ] Idle-Timeout: 15 Minuten
- [ ] Absolute-Timeout: 8 Stunden
- [ ] Test: Session wird nach 15min Inaktivit√§t ung√ºltig
- [ ] Test: Session wird nach 8h ung√ºltig

---

### 3. 403-Audit-Events in RBAC-Middleware
**Warum:** Angriffsversuche (403) werden aktuell nicht geloggt (widerspricht Shard 03)  
**Risiko:** Mittel  
**Aufwand:** ~30min

**Implementierung in `middlewares/rbac.ts`:**
```typescript
import { writeAudit } from '../services/auditService.js';

export function requireRoles(required: string[]) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const user = (req.session as any)?.user as { id: string; roles: string[] } | undefined;
    if (!user) return res.status(401).json({ error: 'unauthenticated' });
    const has = required.some(r => user.roles.includes(r));
    if (!has) {
      // Audit-Event schreiben
      await writeAudit({
        actorUserId: user.id,
        entityType: 'Access',
        action: 'DENIED',
        after: { 
          endpoint: req.path, 
          method: req.method, 
          ip: req.ip,
          requiredRoles: required,
          userRoles: user.roles
        }
      });
      return res.status(403).json({ error: 'forbidden' });
    }
    next();
  };
}
```

**Checklist:**
- [ ] `writeAudit` bei 403 aufgerufen
- [ ] Audit-Event enth√§lt: Endpunkt, Methode, IP, erforderliche Rollen
- [ ] Test: Nach 403 ist Audit-Event in DB vorhanden
- [ ] DB-Query: `SELECT * FROM AuditEvent WHERE action='DENIED'` funktioniert

---

### 4. CSRF-Schutz f√ºr Admin-Formulare
**Warum:** Admin-UI ist anf√§llig f√ºr Cross-Site Request Forgery  
**Risiko:** Hoch  
**Aufwand:** ~2h

```bash
npm install csurf
```

**Implementierung in `server.ts`:**
```typescript
import csrf from 'csurf';

const csrfProtection = csrf({ cookie: true });

// Nur f√ºr Admin-UI-Routen (nicht f√ºr API-JSON-Endpunkte)
app.use('/admin', csrfProtection);

// Token in Views verf√ºgbar machen
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken ? req.csrfToken() : null;
  next();
});
```

**In EJS-Templates:**
```html
<form method="POST">
  <input type="hidden" name="_csrf" value="<%= csrfToken %>">
  <!-- Formularfelder -->
</form>
```

**Checklist:**
- [ ] `csurf` installiert
- [ ] CSRF-Token in alle Admin-Formulare eingef√ºgt
- [ ] Test: POST ohne Token wird mit 403 abgewiesen
- [ ] Test: POST mit g√ºltigem Token funktioniert

---

### 5. Passwort-Policy-Validierung
**Warum:** Aktuell sind schwache Passw√∂rter erlaubt (widerspricht Shard 03)  
**Risiko:** Mittel  
**Aufwand:** ~1h

```bash
npm install zxcvbn
```

**Implementierung in `services/authService.ts`:**
```typescript
import zxcvbn from 'zxcvbn';

const COMMON_PASSWORDS = ['password', 'admin123', '123456', 'qwerty']; // erweitern

export function validatePasswordPolicy(password: string, email: string): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Mindestl√§nge 12
  if (password.length < 12) {
    errors.push('Passwort muss mindestens 12 Zeichen lang sein');
  }
  
  // Zxcvbn-St√§rke ‚â• 3
  const result = zxcvbn(password, [email]);
  if (result.score < 3) {
    errors.push('Passwort ist zu schwach. Verwenden Sie eine Kombination aus Buchstaben, Zahlen und Sonderzeichen.');
  }
  
  // Blacklist
  if (COMMON_PASSWORDS.some(p => password.toLowerCase().includes(p))) {
    errors.push('Passwort ist zu h√§ufig verwendet. W√§hlen Sie ein sichereres Passwort.');
  }
  
  return { valid: errors.length === 0, errors };
}
```

**In `routes/users.ts` und `routes/auth.ts`:**
```typescript
const validation = validatePasswordPolicy(password, email);
if (!validation.valid) {
  return res.status(400).json({ errors: validation.errors });
}
```

**Checklist:**
- [ ] `zxcvbn` installiert
- [ ] Validierung in User-Create implementiert
- [ ] Validierung in Password-Reset implementiert
- [ ] Test: Passwort < 12 Zeichen wird abgelehnt
- [ ] Test: Passwort mit Zxcvbn-Score < 3 wird abgelehnt
- [ ] Test: Blacklist-Passwort wird abgelehnt

---

### 6. Argon2id statt bcrypt
**Warum:** Shard 03 fordert explizit Argon2id (moderner, resistenter gegen GPU-Angriffe)  
**Risiko:** Niedrig (bcrypt ist OK, aber nicht Spec-konform)  
**Aufwand:** ~1h

```bash
npm install argon2
```

**Implementierung in `services/authService.ts`:**
```typescript
import argon2 from 'argon2';

export async function hashPassword(plain: string) {
  return argon2.hash(plain, { 
    type: argon2.argon2id,
    memoryCost: 2 ** 16, // 64 MB
    timeCost: 3,
    parallelism: 1
  });
}

export async function verifyPassword(plain: string, hash: string) {
  try {
    return await argon2.verify(hash, plain);
  } catch {
    return false;
  }
}
```

**Migration-Strategie:**
- Neue Passw√∂rter werden mit Argon2id gehasht
- Bestehende bcrypt-Hashes bleiben g√ºltig (Hybrid-Verifikation)
- Beim n√§chsten Login wird Hash automatisch auf Argon2id migriert

**Checklist:**
- [ ] `argon2` installiert
- [ ] `hashPassword` auf Argon2id umgestellt
- [ ] `verifyPassword` unterst√ºtzt bcrypt-Hashes (Fallback)
- [ ] Test: Neues Passwort wird mit Argon2id gehasht
- [ ] Test: Alte bcrypt-Hashes funktionieren weiterhin
- [ ] Migration-Script f√ºr bestehende Passw√∂rter (optional)

---

### 7. SESSION_SECRET aus Environment
**Warum:** Hardcodierter Default `'change-me'` ist inakzeptabel f√ºr Produktion  
**Risiko:** Kritisch  
**Aufwand:** ~15min

**`.env` (nicht committen!):**
```env
SESSION_SECRET=<generiert mit: openssl rand -base64 32>
NODE_ENV=production
DATABASE_URL=file:./prod.db
```

**In `server.ts`:**
```typescript
if (!process.env.SESSION_SECRET) {
  throw new Error('SESSION_SECRET muss in .env gesetzt sein');
}

app.use(session({
  secret: process.env.SESSION_SECRET,
  // ...
}));
```

**Checklist:**
- [ ] `.env.example` mit Platzhalter erstellt
- [ ] `.env` in `.gitignore`
- [ ] SESSION_SECRET generiert (32+ Zeichen)
- [ ] Server wirft Fehler, wenn SESSION_SECRET fehlt
- [ ] Deployment-Docs aktualisiert (Env-Variable setzen)

---

## üü† Priorit√§t 2: Wichtige Features (Sollte)

### 8. Recovery-Codes f√ºr 2FA
**Warum:** Benutzer k√∂nnen ausgesperrt werden, wenn TOTP-Ger√§t verloren geht  
**Aufwand:** ~2h

**Schema-Erweiterung `schema.prisma`:**
```prisma
model User {
  // ...
  recoveryCodes String[] // Array von gehashten Codes
}
```

**Implementierung in `routes/auth.ts`:**
```typescript
import crypto from 'crypto';

function generateRecoveryCodes(count = 10): string[] {
  return Array.from({ length: count }, () => 
    crypto.randomBytes(4).toString('hex').toUpperCase()
  );
}

router.post('/enable-2fa', async (req, res) => {
  // ... existing code ...
  
  const recoveryCodes = generateRecoveryCodes();
  const hashedCodes = await Promise.all(
    recoveryCodes.map(code => hashPassword(code))
  );
  
  await prisma.user.update({
    where: { id: actor.id },
    data: { 
      twoFactorSecret: secret, 
      twoFactorEnabled: true,
      recoveryCodes: hashedCodes
    }
  });
  
  res.json({ secret, recoveryCodes }); // Einmalige Anzeige!
});

router.post('/login-recovery', async (req, res) => {
  const { email, password, recoveryCode } = req.body;
  const user = await getUserWithRolesByEmail(email);
  // ... password check ...
  
  // Recovery-Code pr√ºfen
  for (const hashedCode of user.recoveryCodes || []) {
    if (await verifyPassword(recoveryCode, hashedCode)) {
      // Code verbrauchen (aus Array entfernen)
      const newCodes = user.recoveryCodes.filter(c => c !== hashedCode);
      await prisma.user.update({
        where: { id: user.id },
        data: { recoveryCodes: newCodes }
      });
      
      // Session erstellen
      // ... existing login logic ...
      return res.json({ ok: true });
    }
  }
  
  return res.status(401).json({ error: 'Ung√ºltiger Recovery-Code' });
});
```

**Checklist:**
- [ ] Schema migriert (`npx prisma migrate dev`)
- [ ] 10 Recovery-Codes bei 2FA-Aktivierung generiert
- [ ] Codes werden gehashed gespeichert
- [ ] Codes werden nur einmalig angezeigt
- [ ] UI: Download-Button f√ºr Codes (TXT-Datei)
- [ ] Recovery-Login-Endpunkt funktioniert
- [ ] Verwendeter Code wird entfernt
- [ ] Test: Login mit Recovery-Code erfolgreich
- [ ] Test: Zweite Verwendung desselben Codes schl√§gt fehl

---

### 9. QR-Code-Generierung f√ºr TOTP
**Warum:** Manuelle Secret-Eingabe ist fehleranf√§llig, QR-Code ist Standard  
**Aufwand:** ~1h

```bash
npm install qrcode
```

**Implementierung:**
```typescript
import QRCode from 'qrcode';

router.post('/enable-2fa', async (req, res) => {
  // ... existing code ...
  
  const user = await prisma.user.findUnique({ where: { id: actor.id } });
  const otpauthUrl = authenticator.keyuri(
    user!.email, 
    'Jetson Dashboard', 
    secret
  );
  
  const qrCodeDataUrl = await QRCode.toDataURL(otpauthUrl);
  
  res.json({ secret, qrCodeDataUrl, recoveryCodes });
});
```

**In Admin-UI (`views/admin/users.ejs`):**
```html
<img src="<%= qrCodeDataUrl %>" alt="TOTP QR Code">
<p>Oder manuell: <%= secret %></p>
```

**Checklist:**
- [ ] `qrcode` installiert
- [ ] QR-Code-URL generiert
- [ ] UI zeigt QR-Code an
- [ ] Test: QR-Code scannen mit Authenticator-App funktioniert

---

### 10. Admin-Handbuch & API-Dokumentation
**Warum:** Betrieb ohne Dokumentation ist fehleranf√§llig  
**Aufwand:** ~3h

**Zu erstellen:**

1. **Admin-Handbuch (`docs/admin-guide.md`):**
   - Benutzer anlegen, bearbeiten, deaktivieren
   - Rollen zuweisen/entziehen
   - 2FA aktivieren/deaktivieren
   - Recovery-Codes verwenden
   - Passwort-Reset durchf√ºhren
   - Audit-Logs einsehen

2. **API-Referenz (`docs/api-reference.md`):**
   - Alle Endpunkte mit Beispielen
   - Request/Response-Schemas
   - RBAC-Anforderungen
   - Fehler-Codes

3. **Deployment-Guide (`docs/deployment.md`):**
   - Environment-Variablen
   - TLS/Caddy-Konfiguration
   - Datenbank-Migrationen
   - Backup-Strategie

**Checklist:**
- [ ] Admin-Handbuch geschrieben
- [ ] API-Referenz mit Beispielen
- [ ] Deployment-Guide mit Env-Variablen
- [ ] Screenshots f√ºr UI-Flows
- [ ] Troubleshooting-Sektion

---

## üü¢ Priorit√§t 3: UX-Verbesserungen (Kann)

### 11. Such-/Filter-Funktionalit√§t in UI
**Aufwand:** ~2h

**API-Erweiterung:**
```typescript
router.get('/', requireRoles(['admin']), async (req, res) => {
  const { query, role, active, limit = 50, offset = 0 } = req.query;
  
  const users = await prisma.user.findMany({
    where: {
      AND: [
        query ? {
          OR: [
            { name: { contains: String(query) } },
            { email: { contains: String(query) } }
          ]
        } : {},
        active !== undefined ? { isActive: active === 'true' } : {},
        role ? { roles: { some: { role: { name: String(role) } } } } : {}
      ]
    },
    include: { roles: { include: { role: true } } },
    take: Number(limit),
    skip: Number(offset)
  });
  
  res.json(users);
});
```

**Checklist:**
- [ ] Such-Feld in UI
- [ ] Filter-Dropdowns (Rolle, Status)
- [ ] Pagination-Controls
- [ ] Backend-Endpoints angepasst

---

## Manuelle Test-Checkliste (nach P1-Implementierung)

### Admin-UI
- [ ] Login mit Admin erfolgreich
- [ ] Benutzer anlegen ‚Üí erscheint in Liste
- [ ] Benutzer bearbeiten ‚Üí √Ñnderung sichtbar
- [ ] Benutzer deaktivieren ‚Üí Status √§ndert sich
- [ ] Rolle zuweisen ‚Üí Badge erscheint
- [ ] 2FA aktivieren ‚Üí QR-Code erscheint
- [ ] Recovery-Codes anzeigen ‚Üí Download funktioniert

### RBAC
- [ ] Non-Admin-User: `/users` ‚Üí 403
- [ ] Vendor-Readonly: `/admin/services` ‚Üí 403
- [ ] Admin: Alle Endpunkte ‚Üí 200/201

### Security
- [ ] 6. Login-Versuch ‚Üí Rate-Limit-Fehler
- [ ] Session nach 15min Idle ‚Üí 401
- [ ] Session nach 8h ‚Üí 401
- [ ] POST ohne CSRF-Token ‚Üí 403
- [ ] Schwaches Passwort (z.B. "admin") ‚Üí 400

### Audit
- [ ] User-Create ‚Üí Audit-Event in DB
- [ ] 403-Fehler ‚Üí Audit-Event mit "DENIED"
- [ ] 2FA-Enable ‚Üí Audit-Event

---

## Definition of Done (√ºberarbeitet)

- [x] Benutzer-CRUD vollst√§ndig
- [x] Rollen-CRUD vollst√§ndig
- [x] RBAC wirksam (403 getestet)
- [x] 2FA optional aktivierbar, TOTP-Login
- [x] Audit-Events bei allen √Ñnderungen
- [ ] **Rate-Limiting implementiert** (P1)
- [ ] **Session-H√§rtung** (P1)
- [ ] **CSRF-Schutz** (P1)
- [ ] **Passwort-Policy** (P1)
- [ ] **403-Audit-Events** (P1)
- [ ] **Argon2id** (P1)
- [ ] Recovery-Codes (P2)
- [ ] QR-Code-Generierung (P2)
- [ ] **Dokumentation** (P2)
- [ ] Manuelle Tests bestanden
- [ ] Security-Review nach H√§rtung

---

## Timeline

**Woche 1 (Tag 1-3): P1-Implementierung**
- Tag 1: Rate-Limiting, Session-H√§rtung, 403-Audit
- Tag 2: CSRF, Passwort-Policy, Argon2id
- Tag 3: Manuelle Tests, Bug-Fixes

**Woche 2 (Tag 4-6): P2-Implementierung**
- Tag 4: Recovery-Codes, QR-Codes
- Tag 5: Dokumentation schreiben
- Tag 6: Finaler Review, Prod-Deployment

---

**Aktueller Status:** üî¥ 7/14 P1-Items offen  
**Ziel:** ‚úÖ Alle P1-Items in 2-3 Tagen  
**N√§chster Milestone:** Security-Review nach P1-H√§rtung

