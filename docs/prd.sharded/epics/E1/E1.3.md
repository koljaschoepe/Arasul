# Story E1.3 – VPN-only Erreichbarkeit

Ziel: Dienste sind ausschließlich über WireGuard-VPN erreichbar; kein Public-Exposure. Orientierung an den Architektur-Shards (siehe `architect.README.md` – Security-Architektur, Runtime-Topologie, Netz & Ports).

Beschreibung:
- Alle HTTPS-Dienste (Dashboard, API, n8n, MinIO, Guacamole, Monitoring) sind nur über WireGuard-VPN erreichbar.
- WireGuard-Server läuft auf dem Jetson-Gerät und verwaltet VPN-Clients (Peers).
- Firewall-Regeln (iptables) blockieren direkten Zugriff auf Ports 80/443 von Public-IPs.
- Nur der WireGuard-Port (51820/UDP) ist öffentlich exponiert.
- VPN-Clients erhalten IPs im 10.80.1.0/24-Subnetz und können über diese IPs auf HTTPS-Dienste zugreifen.

In Scope (MVP):
- WireGuard-Server-Installation und Konfiguration
- Automatische Generierung von Server- und Client-Konfigurationen
- Firewall-Regeln (iptables) für VPN-only Zugriff
- Client-Konfigurations-Export (QR-Code + .conf-Datei)
- Health-Checks für WireGuard-Verbindung
- Dokumentation für Client-Setup (macOS, Linux, Windows, iOS, Android)

Out of Scope (MVP):
- Multi-User-VPN-Management-UI (manuell via CLI für MVP)
- Key-Rotation-Automatisierung (manuell für MVP)
- Peer-Revocation-UI (manuell via CLI)
- VPN-Bandwidth-Monitoring (Phase 2)

Akzeptanzkriterien:
- WireGuard-Server läuft und ist über Port 51820/UDP erreichbar.
- VPN-Clients können sich verbinden und erhalten IPs im 10.80.1.0/24-Subnetz.
- HTTPS-Dienste (443/TCP) sind nur über VPN-IP erreichbar; direkter Zugriff von Public-IP wird geblockt.
- HTTP-Port (80/TCP) leitet auf HTTPS um, aber nur über VPN erreichbar.
- Firewall-Regeln sind persistent (überleben Reboot).
- Health-Check: `curl https://10.80.1.1/api/health` liefert 200 OK mit aktiver VPN-Verbindung; von Public-IP nicht erreichbar (Timeout/Connection Refused).
- Client-Konfiguration (QR-Code + .conf) kann exportiert werden.
- Tests belegen: Ohne VPN keine Erreichbarkeit der Dienste (403/Timeout).

Haupt-Flows:
- **VPN-Server-Setup:** Admin führt Setup-Skript aus → WireGuard installiert, Server-Key generiert, wg0-Interface konfiguriert → WireGuard-Service startet.
- **Client hinzufügen:** Admin führt `add-client.sh <client-name>` aus → Client-Key generiert, wg0.conf aktualisiert, QR-Code + .conf exportiert → Admin scannt QR-Code oder importiert .conf in WireGuard-App.
- **Client-Verbindung:** Client aktiviert VPN → erhält IP (z.B. 10.80.1.2) → greift auf `https://10.80.1.1/` zu → Dashboard lädt.
- **Firewall-Test:** Externer Angreifer versucht `curl https://<public-ip>/` → Timeout/Connection Refused (Port geblockt).

Nicht-funktional (Verweise):
- Security-Architektur (Shard 03): VPN-only Zugriff als Kernkomponente der Zero-Trust-Strategie.
- Netz & Ports (Shard 10): Port 51820/UDP öffentlich, Ports 80/443 nur VPN/LAN.
- Runtime-Topologie (Shard 02): Netzfluss Client → WireGuard → Caddy → Services.

Abhängigkeiten:
- Architektur-Shards: 03 Security, 10 Netz & Ports, 02 Runtime-Topologie (siehe `architect.README.md`).
- E1.2 (TLS & Security-Header) sollte abgeschlossen sein (VPN-Zugriff baut auf HTTPS auf).
- Linux-Kernel mit WireGuard-Unterstützung (standardmäßig in JetPack ≥5.x).

Risiken & Mitigation:
- **VPN-Key-Verlust:** Client-Key kompromittiert → Angreifer kann VPN nutzen.
  - Mitigation: Peer-Revocation-Prozess dokumentiert; Rotation-UI in Phase 2.
- **Firewall-Fehlkonfiguration:** Ports versehentlich offen → Public-Exposure.
  - Mitigation: Automatisierte Tests prüfen Firewall-Regeln; Script validiert iptables.
- **WireGuard-Downtime:** VPN-Service crashed → kein Zugriff auf System.
  - Mitigation: Fallback-Zugriff via Lokal-LAN; WireGuard systemd-Service mit Auto-Restart.
- **Performance auf Nano:** WireGuard-Overhead bei hoher Last.
  - Mitigation: Monitoring (Prometheus); bei Bedarf Kernel-WireGuard (statt Userspace).
- **NAT-Traversal / CG-NAT:** Clients hinter Carrier-Grade NAT können VPN nicht aufbauen.
  - Mitigation: PersistentKeepalive aktiviert (bereits in Client-Config); Troubleshooting-Guide für Port-Forwarding; Alternative: IPv6-VPN (Phase 2).

Definition of Done:
- Alle Akzeptanzkriterien erfüllt und durch Tests abgedeckt (VPN-Erreichbarkeit, Firewall-Blockade).
- WireGuard-Service läuft und überlebt Reboots.
- Firewall-Regeln persistent (via `/etc/iptables/rules.v4` oder äquivalent).
- Client-Setup-Dokumentation vollständig (QR-Code, .conf-Import, Troubleshooting).
- Automatisierte Tests: Dienste ohne VPN nicht erreichbar, mit VPN erreichbar.
- Security-Review gemäß Threat-Model-Checkliste des Architektur-Shards durchgeführt.

---

## Tasks / Subtasks

### Task 1: WireGuard-Installation & Konfiguration (AC: 1, 2)
- [ ] WireGuard-Paket installieren (`apt install wireguard`)
- [ ] Server-Keys generieren (`wg genkey | tee privatekey | wg pubkey > publickey`)
- [ ] `/etc/wireguard/wg0.conf` erstellen mit:
  - Interface: 10.80.1.1/24 (Server-IP)
  - ListenPort: 51820
  - PrivateKey: [generiert]
  - PostUp/PostDown: iptables-Regeln für NAT
- [ ] systemd-Service aktivieren (`systemctl enable wg-quick@wg0`)
- [ ] WireGuard starten (`systemctl start wg-quick@wg0`)
- [ ] Health-Check: `wg show` zeigt Interface

### Task 2: Firewall-Regeln (iptables) (AC: 3, 4)
- [ ] iptables-Regeln für VPN-only Zugriff erstellen:
  - ACCEPT: wg0 (VPN-Interface) → 443/TCP, 80/TCP
  - ACCEPT: lo (Loopback) → alle Ports (für lokale Tests)
  - ACCEPT: 51820/UDP (WireGuard-Port) von allen IPs
  - DROP: eth0/wlan0 → 443/TCP, 80/TCP (Public-IPs geblockt)
- [ ] iptables-Rules persistent machen (`iptables-persistent` oder `/etc/iptables/rules.v4`)
- [ ] Reboot-Test: Firewall-Regeln nach Neustart weiterhin aktiv

### Task 3: Client-Konfigurations-Export (AC: 7)
- [ ] Script `scripts/add-vpn-client.sh` erstellen:
  - Generiert Client-Keys
  - Fügt Peer zu `/etc/wireguard/wg0.conf` hinzu
  - Erstellt Client-`.conf`-Datei
  - Generiert QR-Code (`qrencode -t ansiutf8 < client.conf`)
- [ ] Dokumentation: Client-Setup für verschiedene Plattformen (macOS, Linux, Windows, iOS, Android)
- [ ] Test: QR-Code scannen mit WireGuard-App → Verbindung erfolgreich

### Task 4: Health-Checks & Monitoring (AC: 6)
- [ ] Health-Check-Endpoint: `GET /api/vpn/status` (nur für admins)
  - Zeigt: Anzahl aktiver Peers, RX/TX Bytes, Uptime
  - Basis: `wg show wg0 dump`
- [ ] Prometheus-Metriken für WireGuard (Phase 1.5, Out of Scope für MVP):
  - `wireguard_peers_total`
  - `wireguard_rx_bytes_total{peer}`
  - `wireguard_tx_bytes_total{peer}`

### Task 5: Automatisierte Tests (AC: 8)
- [ ] Test 1: **VPN-Erreichbarkeit**
  - Setup: WireGuard-Client aktiviert
  - Action: `curl -k https://10.80.1.1/api/health`
  - Expected: 200 OK
- [ ] Test 2: **Public-IP-Blockade**
  - Setup: WireGuard-Client deaktiviert
  - Action: `curl --connect-timeout 5 https://<public-ip>/api/health`
  - Expected: Timeout oder Connection Refused
- [ ] Test 3: **Firewall-Persistenz**
  - Setup: Reboot
  - Action: Prüfe `iptables -L -n | grep 443`
  - Expected: DROP-Regeln weiterhin vorhanden
- [ ] Test 4: **WireGuard-Service-Uptime**
  - Action: `systemctl is-active wg-quick@wg0`
  - Expected: `active`

### Task 6: Dokumentation (AC: 7)
- [ ] `/docs/deployment/vpn-setup.md` erstellen:
  - Server-Setup-Anleitung
  - Client-Setup (QR-Code, .conf-Import)
  - Troubleshooting (Verbindung schlägt fehl, DNS-Probleme, Firewall-Debug)
  - Peer-Revocation (manuell via `wg set wg0 peer <pubkey> remove`)
- [ ] `/scripts/README.md` aktualisieren:
  - `add-vpn-client.sh` Dokumentation
  - Beispiel-Aufrufe
- [ ] Security-Hinweise:
  - Client-Keys sicher aufbewahren
  - QR-Codes nicht in Logs/Screenshots teilen
  - Peer-Revocation bei Key-Verlust

---

## Dev Notes

### Context from Previous Stories (E1.1, E1.2)

**E1.1 – Benutzer- & Rollenverwaltung:**
- RBAC-Enforcement ist bereits implementiert.
- VPN-Status-Endpoint sollte nur für `admin`-Rolle zugänglich sein.
- Health-Check nutzt bestehende RBAC-Middleware.

**E1.2 – TLS & Security-Header:**
- HTTPS (Caddy) ist bereits konfiguriert mit TLS 1.3.
- VPN-Zugriff baut auf HTTPS auf (Clients greifen auf `https://10.80.1.1` zu).
- Firewall-Regeln aus E1.2 dokumentiert; E1.3 implementiert sie.

**Lessons Learned:**
- **Frühe Security-Checkliste:** Threat-Model-Review VOR Implementierung (Erfolg in E1.1/E1.2).
- **Automatisierte Tests:** Firewall-Tests sollten in CI/CD integriert werden (analog E1.2 Security-Header-Tests).
- **Dokumentation:** Troubleshooting-Guides sind kritisch (VPN-Setup ist fehleranfällig bei Erstnutzern).

---

## Architecture Context

### WireGuard & VPN-Topologie

[Source: architect.10-network-ports.md]

**Ports:**
- 51820/UDP: WireGuard (eingehend, öffentlich exponiert)
- 443/TCP: HTTPS (nur VPN/LAN)
- 80/TCP: HTTP Redirect (nur VPN/LAN)

**Netzfluss (Erweitert):**
```
Client (z.B. 192.168.1.100)
  ↓ [WireGuard Tunnel]
WireGuard-Server (Jetson, 10.80.1.1)
  ↓ [wg0 Interface]
iptables (Firewall: nur wg0 → 443/TCP erlaubt)
  ↓
Caddy (TLS-Terminierung, 443/TCP)
  ↓ [Reverse-Proxy]
Services (Dashboard, API, n8n, MinIO, Guacamole)
```

**Subnetz-Zuweisung:**
- Server: 10.80.1.1/24 (WireGuard-Interface wg0)
- Clients: 10.80.1.2 - 10.80.1.254 (bis zu 253 Peers)
- Internes Docker-Netzwerk: 172.20.0.0/16 (siehe `docker-compose.yml`)

**Wichtig:** VPN-Subnetz (10.80.1.0/24) ≠ Docker-Netzwerk (172.20.0.0/16)!

[Source: architect.02-runtime-topology.md]

**Netzfluss (vereinfacht):**
1. Client verbindet WireGuard → erhält IP im 10.80.1.0/24.
2. Zugriff via `https://10.80.1.1/…` → Caddy terminiert TLS und routet intern per Subpfad.
3. Dashboard-Frontend spricht Backend-API und WebSocket-Endpunkte für Live-Metriken.

### Security Requirements

[Source: prd.sharded/12-functional-requirements.md → FR-VPN-001]

**FR-VPN-001 – WireGuard-only Zugriff**
- Zugriff ausschließlich über WireGuard-VPN-Subnetz

**Akzeptanzkriterien:**
- Dienste nur über VPN-IP erreichbar; keine Public-Exposition

[Source: prd.sharded/13-nfrs-overview.md]

**NFR-Security:**
- TLS 1.3, A+ Rating (bereits in E1.2)
- VPN-only Zugriff (diese Story)
- 0 Critical/High CVEs

[Source: architect.11-threat-model.md]

**Bedrohungen:**
- VPN-Key-Diebstahl → Unbefugter Zugriff auf System
- Schwache Firewall-Regeln → Public-Exposure trotz VPN

**Mitigation:**
- Key-Rotation, Peer-Revocation (dokumentiert für MVP, UI in Phase 2)
- Automatisierte Firewall-Tests (CI/CD)
- Audit-Logs für VPN-Verbindungen (optional, Phase 2)

[Source: architect.03-security-architecture.md]

**Security-Strategie:**
- VPN-only Zugriff als erste Verteidigungslinie (Defense in Depth)
- Kombiniert mit RBAC, TLS, Security-Header für mehrschichtige Sicherheit

---

## Technical Implementation Details

### WireGuard-Server-Konfiguration

**Server-Config (`/etc/wireguard/wg0.conf`):**
```ini
[Interface]
Address = 10.80.1.1/24
ListenPort = 51820
PrivateKey = <SERVER_PRIVATE_KEY>

# NAT für ausgehenden Traffic
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Peer 1: Admin-Laptop
[Peer]
PublicKey = <CLIENT_1_PUBLIC_KEY>
AllowedIPs = 10.80.1.2/32

# Peer 2: Smartphone
[Peer]
PublicKey = <CLIENT_2_PUBLIC_KEY>
AllowedIPs = 10.80.1.3/32
```

**Key-Generierung:**
```bash
# Server-Keys
wg genkey | tee /etc/wireguard/server_privatekey | wg pubkey > /etc/wireguard/server_publickey

# Client-Keys
wg genkey | tee client_privatekey | wg pubkey > client_publickey
```

### Client-Konfiguration

**Client-Config (Beispiel für Admin-Laptop):**
```ini
[Interface]
PrivateKey = <CLIENT_PRIVATE_KEY>
Address = 10.80.1.2/32
DNS = 1.1.1.1  # Optional: DNS-Server

[Peer]
PublicKey = <SERVER_PUBLIC_KEY>
Endpoint = <JETSON_PUBLIC_IP>:51820
AllowedIPs = 10.80.1.0/24  # Nur Traffic für VPN-Subnetz über VPN routen
PersistentKeepalive = 25   # Für NAT-Traversal
```

**QR-Code-Generierung:**
```bash
qrencode -t ansiutf8 < client.conf
qrencode -o client-qr.png < client.conf  # Für iOS/Android WireGuard-App
```

### Firewall-Regeln (iptables)

**Strategie:**
- ACCEPT: WireGuard-Port (51820/UDP) von allen IPs (für VPN-Verbindungen)
- ACCEPT: Ports 80/443 nur von wg0-Interface (VPN)
- ACCEPT: Loopback (lo) für lokale Tests
- DROP: Ports 80/443 von Public-Interfaces (eth0, wlan0)

**iptables-Script (`/etc/iptables/rules.v4`):**
```bash
*filter
# Default-Policies
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]

# Loopback erlauben
-A INPUT -i lo -j ACCEPT

# Established/Related Verbindungen erlauben
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# WireGuard-Port (51820/UDP) öffentlich
-A INPUT -p udp --dport 51820 -j ACCEPT

# HTTPS (443/TCP) nur von VPN (wg0)
-A INPUT -i wg0 -p tcp --dport 443 -j ACCEPT

# HTTP (80/TCP) nur von VPN (wg0) für Redirect
-A INPUT -i wg0 -p tcp --dport 80 -j ACCEPT

# HTTPS/HTTP von Public-Interfaces BLOCKEN
-A INPUT -i eth0 -p tcp --dport 443 -j DROP
-A INPUT -i eth0 -p tcp --dport 80 -j DROP
-A INPUT -i wlan0 -p tcp --dport 443 -j DROP
-A INPUT -i wlan0 -p tcp --dport 80 -j DROP

# SSH (22/TCP) nur von VPN (optional, für Remote-Management)
-A INPUT -i wg0 -p tcp --dport 22 -j ACCEPT

# Prometheus/Grafana nur von VPN (optional, für Monitoring)
-A INPUT -i wg0 -p tcp --dport 9090 -j ACCEPT
-A INPUT -i wg0 -p tcp --dport 3001 -j ACCEPT

COMMIT
```

**Persistenz-Setup:**
```bash
# iptables-persistent installieren (Debian/Ubuntu)
apt install iptables-persistent

# Regeln speichern
iptables-save > /etc/iptables/rules.v4

# Bei Änderungen: Regeln neu laden
iptables-restore < /etc/iptables/rules.v4
```

### Scripts

**`scripts/add-vpn-client.sh`:**
```bash
#!/bin/bash
# Add WireGuard VPN Client

set -e

CLIENT_NAME=$1
if [ -z "$CLIENT_NAME" ]; then
  echo "Usage: $0 <client-name>"
  exit 1
fi

# Generiere Client-Keys
CLIENT_PRIVATE_KEY=$(wg genkey)
CLIENT_PUBLIC_KEY=$(echo "$CLIENT_PRIVATE_KEY" | wg pubkey)

# Nächste freie IP finden
LAST_IP=$(wg show wg0 allowed-ips | grep -oP '10\.80\.1\.\K\d+' | sort -n | tail -1)
NEXT_IP=$((LAST_IP + 1))
CLIENT_IP="10.80.1.$NEXT_IP"

# Server-Public-Key auslesen
SERVER_PUBLIC_KEY=$(cat /etc/wireguard/server_publickey)
SERVER_ENDPOINT=${SERVER_PUBLIC_IP:-$(curl -s ifconfig.me 2>/dev/null || echo "")}:51820
if [ -z "${SERVER_ENDPOINT%:51820}" ] || [ "${SERVER_ENDPOINT%:51820}" = "" ]; then
  echo "ERROR: Could not detect public IP. Set SERVER_PUBLIC_IP env variable."
  exit 1
fi

# Peer zu Server-Config hinzufügen
cat >> /etc/wireguard/wg0.conf <<EOF

# Peer: $CLIENT_NAME
[Peer]
PublicKey = $CLIENT_PUBLIC_KEY
AllowedIPs = $CLIENT_IP/32
EOF

# WireGuard neu laden
wg syncconf wg0 <(wg-quick strip wg0)

# Client-Config generieren
CLIENT_CONF="/tmp/$CLIENT_NAME.conf"
cat > "$CLIENT_CONF" <<EOF
[Interface]
PrivateKey = $CLIENT_PRIVATE_KEY
Address = $CLIENT_IP/32
DNS = 1.1.1.1

[Peer]
PublicKey = $SERVER_PUBLIC_KEY
Endpoint = $SERVER_ENDPOINT
AllowedIPs = 10.80.1.0/24
PersistentKeepalive = 25
EOF

# QR-Code generieren
echo "Client-Konfiguration erstellt: $CLIENT_CONF"
echo "QR-Code:"
qrencode -t ansiutf8 < "$CLIENT_CONF"

echo ""
echo "Client-IP: $CLIENT_IP"
echo "Konfigurationsdatei: $CLIENT_CONF"
echo ""
echo "Importieren Sie die Konfiguration in die WireGuard-App:"
echo "  - macOS/Linux: wg-quick up $CLIENT_CONF"
echo "  - iOS/Android: QR-Code scannen"
```

**`scripts/test-vpn-firewall.sh`:**
```bash
#!/bin/bash
# Test VPN-only Zugriff

set -e

echo "Test 1: VPN-Erreichbarkeit (wg0)"
curl -k -m 5 https://10.80.1.1/api/health && echo "✅ VPN-Zugriff erfolgreich" || echo "❌ VPN-Zugriff fehlgeschlagen"

echo ""
echo "Test 2: Public-IP-Blockade (eth0)"
PUBLIC_IP=$(ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
curl -k -m 5 https://$PUBLIC_IP/api/health && echo "❌ Public-Zugriff NICHT geblockt (Sicherheitslücke!)" || echo "✅ Public-Zugriff geblockt"

echo ""
echo "Test 3: Firewall-Regeln"
iptables -L -n | grep "DROP.*tcp.*443" && echo "✅ Firewall-Regeln aktiv" || echo "❌ Firewall-Regeln fehlen"
```

---

## File Locations & Project Structure

**Neue Dateien:**
```
jetson/
├── scripts/
│   ├── add-vpn-client.sh           # Client-Setup-Script
│   ├── test-vpn-firewall.sh        # Firewall-Tests
│   └── README.md                   # Script-Dokumentation (erweitert)
├── docs/
│   └── deployment/
│       └── vpn-setup.md            # VPN-Setup-Dokumentation (neu)
└── /etc/wireguard/                 # System-Pfad (nicht im Repo)
    ├── wg0.conf                    # WireGuard-Server-Config
    ├── server_privatekey           # Server-Private-Key (NICHT committen!)
    └── server_publickey            # Server-Public-Key
```

**Bestehende Dateien (Erweitert):**
- `/etc/iptables/rules.v4` - Firewall-Regeln (persistent)
- `docker-compose.yml` - Keine Änderungen (Caddy-Ports bereits konfiguriert)

**Security-Hinweis:**
- Private-Keys NIEMALS in Git committen!
- `.gitignore` erweitern: `*.privatekey`, `*.conf` (Client-Configs)

---

## Testing

### Test-Strategie

**Test-Framework:** Bash-Scripts + Manual Testing

**Test-Coverage:**
1. WireGuard-Service-Uptime
2. VPN-Erreichbarkeit (HTTPS über wg0)
3. Public-IP-Blockade (HTTPS über eth0/wlan0)
4. Firewall-Persistenz (nach Reboot)
5. Client-Konfiguration (QR-Code, .conf-Import)

### Automated Tests

**Test 1: WireGuard-Service**
```bash
#!/bin/bash
# Test: WireGuard-Service aktiv
systemctl is-active --quiet wg-quick@wg0 && echo "✅ WireGuard aktiv" || exit 1
```

**Test 2: VPN-Erreichbarkeit**
```bash
#!/bin/bash
# Test: HTTPS über VPN erreichbar
curl -k -m 5 https://10.80.1.1/api/health -o /dev/null -s -w "%{http_code}" | grep 200 && echo "✅ VPN-Zugriff OK" || exit 1
```

**Test 3: Public-Blockade**
```bash
#!/bin/bash
# Test: HTTPS über Public-IP geblockt
PUBLIC_IP=$(hostname -I | awk '{print $1}')
curl -k -m 5 https://$PUBLIC_IP/api/health && exit 1 || echo "✅ Public-Zugriff geblockt"
```

**Test 4: Firewall-Persistenz**
```bash
#!/bin/bash
# Test: iptables-Regeln nach Reboot
iptables -L -n | grep -q "DROP.*tcp.*dpt:443" && echo "✅ Firewall-Regeln persistent" || exit 1
```

### Manual Tests

**Test 5: Client-Setup (iOS/Android)**
1. Führe `scripts/add-vpn-client.sh smartphone` aus
2. Scanne QR-Code mit WireGuard-App
3. Aktiviere VPN in der App
4. Öffne Safari/Chrome: `https://10.80.1.1/`
5. **Erwartetes Ergebnis:** Dashboard lädt erfolgreich

**Test 6: Client-Setup (macOS/Linux)**
1. Führe `scripts/add-vpn-client.sh laptop` aus
2. Kopiere `/tmp/laptop.conf` zu `/etc/wireguard/laptop.conf`
3. Aktiviere VPN: `sudo wg-quick up laptop`
4. Teste: `curl -k https://10.80.1.1/api/health`
5. **Erwartetes Ergebnis:** 200 OK

**Test 7: Firewall-Bypass-Versuch**
1. Deaktiviere VPN
2. Ermittle Public-IP: `curl ifconfig.me`
3. Versuche Zugriff: `curl -k https://<public-ip>/api/health`
4. **Erwartetes Ergebnis:** Timeout oder Connection Refused

---

## Integration mit E1.1 & E1.2

### RBAC-Integration (E1.1)

**VPN-Status-Endpoint (nur für `admin`):**
```typescript
// app/src/routes/vpn.ts
import express from 'express';
import { requireRole } from '../middlewares/rbac';
import { exec } from 'child_process';
import { promisify } from 'util';

const router = express.Router();
const execAsync = promisify(exec);

// GET /api/vpn/status - WireGuard-Status (nur admin)
router.get('/status', requireRole('admin'), async (req, res) => {
  try {
    const { stdout } = await execAsync('wg show wg0 dump');
    const peers = stdout.trim().split('\n').slice(1); // Erste Zeile ist Interface
    
    res.json({
      interface: 'wg0',
      listenPort: 51820,
      peersCount: peers.length,
      peers: peers.map(peer => {
        const [pubkey, , , rxBytes, txBytes] = peer.split('\t');
        return {
          publicKey: pubkey.substring(0, 16) + '...', // Gekürzt für Security
          rxBytes: parseInt(rxBytes),
          txBytes: parseInt(txBytes)
        };
      })
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch VPN status' });
  }
});

export default router;
```

**Audit-Logging für VPN-Client-Hinzufügung:**
- `add-vpn-client.sh` schreibt Audit-Event: `vpn_client_added` mit `client_name`, `client_ip`, `timestamp`

### TLS-Integration (E1.2)

**VPN-Clients nutzen HTTPS:**
- Clients greifen auf `https://10.80.1.1` zu (VPN-Server-IP)
- Caddy terminiert TLS (bereits in E1.2 konfiguriert)
- Self-signed Zertifikat oder step-ca (Phase 1.5)

**Wichtig:** VPN-Clients müssen CA-Zertifikat importieren (gleicher Prozess wie in E1.2 dokumentiert).

**DNS & Zertifikate:**
- VPN-Clients greifen auf Server via IP (10.80.1.1) oder Hostname (arasul.local) zu
- Zertifikat muss für beide Varianten gültig sein:
  - Self-signed: CN=arasul.local, SAN=IP:10.80.1.1
  - step-ca: `step ca certificate arasul.local cert.pem key.pem --san 10.80.1.1`
- CA-Zertifikat muss auf VPN-Clients importiert werden (siehe E1.2 Dokumentation)

**DNS-Konfiguration (optional):**
- WireGuard-Client-Config kann `DNS = 10.80.1.1` setzen
- Jetson-DNS-Server (z.B. dnsmasq) löst `arasul.local` → `10.80.1.1` auf
- **Scope:** Out of MVP (manuell `https://10.80.1.1` für MVP)

---

## Known Issues & Considerations

1. **WireGuard-Kernel-Modul:**
   - JetPack ≥5.x hat WireGuard im Kernel (kein Problem)
   - Ältere JetPack-Versionen: `wireguard-dkms` installieren
   - **Test:** `modprobe wireguard && lsmod | grep wireguard`

2. **NAT-Traversal:**
   - Clients hinter NAT benötigen `PersistentKeepalive = 25`
   - Bei Problemen: Port-Forwarding auf Router prüfen (51820/UDP)

3. **DNS-Leaks:**
   - Clients sollten VPN-DNS nutzen (in Client-Config: `DNS = 1.1.1.1`)
   - Verhindert DNS-Leaks bei Split-Tunnel

4. **Performance:**
   - WireGuard ist hochperformant, aber auf Nano bei >10 Clients möglich Bottleneck
   - **Mitigation:** Prometheus-Monitoring für VPN-Traffic (Phase 2)

5. **Firewall-Debugging:**
   - Logs aktivieren: `iptables -A INPUT -j LOG --log-prefix "IPT-DROP: "`
   - Logs prüfen: `journalctl -k | grep IPT-DROP`

6. **Key-Management:**
   - Private-Keys MÜSSEN sicher gespeichert werden
   - **Best Practice:** `chmod 600 /etc/wireguard/*.privatekey`
   - Backup-Strategie für Keys dokumentieren

---

## Dependencies & Prerequisites

- **OS:** Linux (Debian/Ubuntu) mit Kernel ≥5.6 (WireGuard integriert)
- **JetPack:** ≥5.x (WireGuard-Unterstützung)
- **Tools:**
  - `wireguard-tools` (`apt install wireguard`)
  - `qrencode` (`apt install qrencode`)
  - `iptables-persistent` (`apt install iptables-persistent`)
- **E1.2:** TLS & Security-Header sollten implementiert sein (VPN-Clients nutzen HTTPS)

---

## Success Metrics

- WireGuard-Service-Uptime: 100% (systemd Auto-Restart)
- VPN-Verbindungen erfolgreich: ≥95% (erste Verbindung)
- Public-IP-Blockade: 100% (automatisierte Tests)
- Firewall-Persistenz: 100% (nach Reboot)
- Client-Setup-Zeit: ≤5 Minuten (QR-Code-Scan)
- Keine Critical/High CVEs in WireGuard-Tools (wöchentlicher Scan via Trivy/Snyk)

---

## Change Log

| Datum | Version | Beschreibung | Autor |
|-------|---------|--------------|-------|
| 2025-10-15 | 1.0 | Story E1.3 erstellt mit vollständigem Context aus Architektur-Shards | Scrum Master (Claude Sonnet 4.5) |
| 2025-10-15 | 1.1 | Story aktualisiert basierend auf Validierungsbericht: Subnetz-Platzhalter (10.80.1.x), Public-IP-Fallback, AC 6 präzisiert, DNS/Zertifikat-Hinweis, NAT-Traversal-Risiko, CVE-Monitoring | Scrum Master (Claude Sonnet 4.5) |

---

## Status

**Status:** 📝 **DRAFT** (Ready for Implementation)

**Next Steps:**
1. Review durch Tech Lead
2. Threat-Model-Checkliste durchgehen (Shard 11)
3. Implementation starten (Task 1: WireGuard-Installation)
4. Tests durchführen
5. QA-Review

---

**Version:** 1.1  
**Datum:** 15. Oktober 2025  
**Erstellt von:** Scrum Master (Claude Sonnet 4.5)  
**Aktualisiert:** 15. Oktober 2025 (Validierungsbericht-Empfehlungen implementiert)
