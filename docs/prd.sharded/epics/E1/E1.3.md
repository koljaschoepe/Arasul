# Story E1.3 ‚Äì VPN-only Erreichbarkeit

Ziel: Dienste sind ausschlie√ülich √ºber WireGuard-VPN erreichbar; kein Public-Exposure. Orientierung an den Architektur-Shards (siehe `architect.README.md` ‚Äì Security-Architektur, Runtime-Topologie, Netz & Ports).

Beschreibung:
- Alle HTTPS-Dienste (Dashboard, API, n8n, MinIO, Guacamole, Monitoring) sind nur √ºber WireGuard-VPN erreichbar.
- WireGuard-Server l√§uft auf dem Jetson-Ger√§t und verwaltet VPN-Clients (Peers).
- Firewall-Regeln (iptables) blockieren direkten Zugriff auf Ports 80/443 von Public-IPs.
- Nur der WireGuard-Port (51820/UDP) ist √∂ffentlich exponiert.
- VPN-Clients erhalten IPs im 10.80.1.0/24-Subnetz und k√∂nnen √ºber diese IPs auf HTTPS-Dienste zugreifen.

In Scope (MVP):
- WireGuard-Server-Installation und Konfiguration
- Automatische Generierung von Server- und Client-Konfigurationen
- Firewall-Regeln (iptables) f√ºr VPN-only Zugriff
- Client-Konfigurations-Export (QR-Code + .conf-Datei)
- Health-Checks f√ºr WireGuard-Verbindung
- Dokumentation f√ºr Client-Setup (macOS, Linux, Windows, iOS, Android)

Out of Scope (MVP):
- Multi-User-VPN-Management-UI (manuell via CLI f√ºr MVP)
- Key-Rotation-Automatisierung (manuell f√ºr MVP)
- Peer-Revocation-UI (manuell via CLI)
- VPN-Bandwidth-Monitoring (Phase 2)

Akzeptanzkriterien:
- WireGuard-Server l√§uft und ist √ºber Port 51820/UDP erreichbar.
- VPN-Clients k√∂nnen sich verbinden und erhalten IPs im 10.80.1.0/24-Subnetz.
- HTTPS-Dienste (443/TCP) sind nur √ºber VPN-IP erreichbar; direkter Zugriff von Public-IP wird geblockt.
- HTTP-Port (80/TCP) leitet auf HTTPS um, aber nur √ºber VPN erreichbar.
- Firewall-Regeln sind persistent (√ºberleben Reboot).
- Health-Check: `curl https://10.80.1.1/api/health` liefert 200 OK mit aktiver VPN-Verbindung; von Public-IP nicht erreichbar (Timeout/Connection Refused).
- Client-Konfiguration (QR-Code + .conf) kann exportiert werden.
- Tests belegen: Ohne VPN keine Erreichbarkeit der Dienste (403/Timeout).

Haupt-Flows:
- **VPN-Server-Setup:** Admin f√ºhrt Setup-Skript aus ‚Üí WireGuard installiert, Server-Key generiert, wg0-Interface konfiguriert ‚Üí WireGuard-Service startet.
- **Client hinzuf√ºgen:** Admin f√ºhrt `add-client.sh <client-name>` aus ‚Üí Client-Key generiert, wg0.conf aktualisiert, QR-Code + .conf exportiert ‚Üí Admin scannt QR-Code oder importiert .conf in WireGuard-App.
- **Client-Verbindung:** Client aktiviert VPN ‚Üí erh√§lt IP (z.B. 10.80.1.2) ‚Üí greift auf `https://10.80.1.1/` zu ‚Üí Dashboard l√§dt.
- **Firewall-Test:** Externer Angreifer versucht `curl https://<public-ip>/` ‚Üí Timeout/Connection Refused (Port geblockt).

Nicht-funktional (Verweise):
- Security-Architektur (Shard 03): VPN-only Zugriff als Kernkomponente der Zero-Trust-Strategie.
- Netz & Ports (Shard 10): Port 51820/UDP √∂ffentlich, Ports 80/443 nur VPN/LAN.
- Runtime-Topologie (Shard 02): Netzfluss Client ‚Üí WireGuard ‚Üí Caddy ‚Üí Services.

Abh√§ngigkeiten:
- Architektur-Shards: 03 Security, 10 Netz & Ports, 02 Runtime-Topologie (siehe `architect.README.md`).
- E1.2 (TLS & Security-Header) sollte abgeschlossen sein (VPN-Zugriff baut auf HTTPS auf).
- Linux-Kernel mit WireGuard-Unterst√ºtzung (standardm√§√üig in JetPack ‚â•5.x).

Risiken & Mitigation:
- **VPN-Key-Verlust:** Client-Key kompromittiert ‚Üí Angreifer kann VPN nutzen.
  - Mitigation: Peer-Revocation-Prozess dokumentiert; Rotation-UI in Phase 2.
- **Firewall-Fehlkonfiguration:** Ports versehentlich offen ‚Üí Public-Exposure.
  - Mitigation: Automatisierte Tests pr√ºfen Firewall-Regeln; Script validiert iptables.
- **WireGuard-Downtime:** VPN-Service crashed ‚Üí kein Zugriff auf System.
  - Mitigation: Fallback-Zugriff via Lokal-LAN; WireGuard systemd-Service mit Auto-Restart.
- **Performance auf Nano:** WireGuard-Overhead bei hoher Last.
  - Mitigation: Monitoring (Prometheus); bei Bedarf Kernel-WireGuard (statt Userspace).
- **NAT-Traversal / CG-NAT:** Clients hinter Carrier-Grade NAT k√∂nnen VPN nicht aufbauen.
  - Mitigation: PersistentKeepalive aktiviert (bereits in Client-Config); Troubleshooting-Guide f√ºr Port-Forwarding; Alternative: IPv6-VPN (Phase 2).

Definition of Done:
- Alle Akzeptanzkriterien erf√ºllt und durch Tests abgedeckt (VPN-Erreichbarkeit, Firewall-Blockade).
- WireGuard-Service l√§uft und √ºberlebt Reboots.
- Firewall-Regeln persistent (via `/etc/iptables/rules.v4` oder √§quivalent).
- Client-Setup-Dokumentation vollst√§ndig (QR-Code, .conf-Import, Troubleshooting).
- Automatisierte Tests: Dienste ohne VPN nicht erreichbar, mit VPN erreichbar.
- Security-Review gem√§√ü Threat-Model-Checkliste des Architektur-Shards durchgef√ºhrt.

---

## Tasks / Subtasks

### Task 1: WireGuard-Installation & Konfiguration (AC: 1, 2)
- [ ] WireGuard-Paket installieren (`apt install wireguard`)
- [ ] Server-Keys generieren (`wg genkey | tee privatekey | wg pubkey > publickey`)
- [ ] `/etc/wireguard/wg0.conf` erstellen mit:
  - Interface: 10.80.1.1/24 (Server-IP)
  - ListenPort: 51820
  - PrivateKey: [generiert]
  - PostUp/PostDown: iptables-Regeln f√ºr NAT
- [ ] systemd-Service aktivieren (`systemctl enable wg-quick@wg0`)
- [ ] WireGuard starten (`systemctl start wg-quick@wg0`)
- [ ] Health-Check: `wg show` zeigt Interface

### Task 2: Firewall-Regeln (iptables) (AC: 3, 4)
- [ ] iptables-Regeln f√ºr VPN-only Zugriff erstellen:
  - ACCEPT: wg0 (VPN-Interface) ‚Üí 443/TCP, 80/TCP
  - ACCEPT: lo (Loopback) ‚Üí alle Ports (f√ºr lokale Tests)
  - ACCEPT: 51820/UDP (WireGuard-Port) von allen IPs
  - DROP: eth0/wlan0 ‚Üí 443/TCP, 80/TCP (Public-IPs geblockt)
- [ ] iptables-Rules persistent machen (`iptables-persistent` oder `/etc/iptables/rules.v4`)
- [ ] Reboot-Test: Firewall-Regeln nach Neustart weiterhin aktiv

### Task 3: Client-Konfigurations-Export (AC: 7)
- [ ] Script `scripts/add-vpn-client.sh` erstellen:
  - Generiert Client-Keys
  - F√ºgt Peer zu `/etc/wireguard/wg0.conf` hinzu
  - Erstellt Client-`.conf`-Datei
  - Generiert QR-Code (`qrencode -t ansiutf8 < client.conf`)
- [ ] Dokumentation: Client-Setup f√ºr verschiedene Plattformen (macOS, Linux, Windows, iOS, Android)
- [ ] Test: QR-Code scannen mit WireGuard-App ‚Üí Verbindung erfolgreich

### Task 4: Health-Checks & Monitoring (AC: 6)
- [ ] Health-Check-Endpoint: `GET /api/vpn/status` (nur f√ºr admins)
  - Zeigt: Anzahl aktiver Peers, RX/TX Bytes, Uptime
  - Basis: `wg show wg0 dump`
- [ ] Prometheus-Metriken f√ºr WireGuard (Phase 1.5, Out of Scope f√ºr MVP):
  - `wireguard_peers_total`
  - `wireguard_rx_bytes_total{peer}`
  - `wireguard_tx_bytes_total{peer}`

### Task 5: Automatisierte Tests (AC: 8)
- [ ] Test 1: **VPN-Erreichbarkeit**
  - Setup: WireGuard-Client aktiviert
  - Action: `curl -k https://10.80.1.1/api/health`
  - Expected: 200 OK
- [ ] Test 2: **Public-IP-Blockade**
  - Setup: WireGuard-Client deaktiviert
  - Action: `curl --connect-timeout 5 https://<public-ip>/api/health`
  - Expected: Timeout oder Connection Refused
- [ ] Test 3: **Firewall-Persistenz**
  - Setup: Reboot
  - Action: Pr√ºfe `iptables -L -n | grep 443`
  - Expected: DROP-Regeln weiterhin vorhanden
- [ ] Test 4: **WireGuard-Service-Uptime**
  - Action: `systemctl is-active wg-quick@wg0`
  - Expected: `active`

### Task 6: Dokumentation (AC: 7)
- [ ] `/docs/deployment/vpn-setup.md` erstellen:
  - Server-Setup-Anleitung
  - Client-Setup (QR-Code, .conf-Import)
  - Troubleshooting (Verbindung schl√§gt fehl, DNS-Probleme, Firewall-Debug)
  - Peer-Revocation (manuell via `wg set wg0 peer <pubkey> remove`)
- [ ] `/scripts/README.md` aktualisieren:
  - `add-vpn-client.sh` Dokumentation
  - Beispiel-Aufrufe
- [ ] Security-Hinweise:
  - Client-Keys sicher aufbewahren
  - QR-Codes nicht in Logs/Screenshots teilen
  - Peer-Revocation bei Key-Verlust

---

## Dev Notes

### Context from Previous Stories (E1.1, E1.2)

**E1.1 ‚Äì Benutzer- & Rollenverwaltung:**
- RBAC-Enforcement ist bereits implementiert.
- VPN-Status-Endpoint sollte nur f√ºr `admin`-Rolle zug√§nglich sein.
- Health-Check nutzt bestehende RBAC-Middleware.

**E1.2 ‚Äì TLS & Security-Header:**
- HTTPS (Caddy) ist bereits konfiguriert mit TLS 1.3.
- VPN-Zugriff baut auf HTTPS auf (Clients greifen auf `https://10.80.1.1` zu).
- Firewall-Regeln aus E1.2 dokumentiert; E1.3 implementiert sie.

**Lessons Learned:**
- **Fr√ºhe Security-Checkliste:** Threat-Model-Review VOR Implementierung (Erfolg in E1.1/E1.2).
- **Automatisierte Tests:** Firewall-Tests sollten in CI/CD integriert werden (analog E1.2 Security-Header-Tests).
- **Dokumentation:** Troubleshooting-Guides sind kritisch (VPN-Setup ist fehleranf√§llig bei Erstnutzern).

---

## Architecture Context

### WireGuard & VPN-Topologie

[Source: architect.10-network-ports.md]

**Ports:**
- 51820/UDP: WireGuard (eingehend, √∂ffentlich exponiert)
- 443/TCP: HTTPS (nur VPN/LAN)
- 80/TCP: HTTP Redirect (nur VPN/LAN)

**Netzfluss (Erweitert):**
```
Client (z.B. 192.168.1.100)
  ‚Üì [WireGuard Tunnel]
WireGuard-Server (Jetson, 10.80.1.1)
  ‚Üì [wg0 Interface]
iptables (Firewall: nur wg0 ‚Üí 443/TCP erlaubt)
  ‚Üì
Caddy (TLS-Terminierung, 443/TCP)
  ‚Üì [Reverse-Proxy]
Services (Dashboard, API, n8n, MinIO, Guacamole)
```

**Subnetz-Zuweisung:**
- Server: 10.80.1.1/24 (WireGuard-Interface wg0)
- Clients: 10.80.1.2 - 10.80.1.254 (bis zu 253 Peers)
- Internes Docker-Netzwerk: 172.20.0.0/16 (siehe `docker-compose.yml`)

**Wichtig:** VPN-Subnetz (10.80.1.0/24) ‚â† Docker-Netzwerk (172.20.0.0/16)!

[Source: architect.02-runtime-topology.md]

**Netzfluss (vereinfacht):**
1. Client verbindet WireGuard ‚Üí erh√§lt IP im 10.80.1.0/24.
2. Zugriff via `https://10.80.1.1/‚Ä¶` ‚Üí Caddy terminiert TLS und routet intern per Subpfad.
3. Dashboard-Frontend spricht Backend-API und WebSocket-Endpunkte f√ºr Live-Metriken.

### Security Requirements

[Source: prd.sharded/12-functional-requirements.md ‚Üí FR-VPN-001]

**FR-VPN-001 ‚Äì WireGuard-only Zugriff**
- Zugriff ausschlie√ülich √ºber WireGuard-VPN-Subnetz

**Akzeptanzkriterien:**
- Dienste nur √ºber VPN-IP erreichbar; keine Public-Exposition

[Source: prd.sharded/13-nfrs-overview.md]

**NFR-Security:**
- TLS 1.3, A+ Rating (bereits in E1.2)
- VPN-only Zugriff (diese Story)
- 0 Critical/High CVEs

[Source: architect.11-threat-model.md]

**Bedrohungen:**
- VPN-Key-Diebstahl ‚Üí Unbefugter Zugriff auf System
- Schwache Firewall-Regeln ‚Üí Public-Exposure trotz VPN

**Mitigation:**
- Key-Rotation, Peer-Revocation (dokumentiert f√ºr MVP, UI in Phase 2)
- Automatisierte Firewall-Tests (CI/CD)
- Audit-Logs f√ºr VPN-Verbindungen (optional, Phase 2)

[Source: architect.03-security-architecture.md]

**Security-Strategie:**
- VPN-only Zugriff als erste Verteidigungslinie (Defense in Depth)
- Kombiniert mit RBAC, TLS, Security-Header f√ºr mehrschichtige Sicherheit

---

## Technical Implementation Details

### WireGuard-Server-Konfiguration

**Server-Config (`/etc/wireguard/wg0.conf`):**
```ini
[Interface]
Address = 10.80.1.1/24
ListenPort = 51820
PrivateKey = <SERVER_PRIVATE_KEY>

# NAT f√ºr ausgehenden Traffic
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Peer 1: Admin-Laptop
[Peer]
PublicKey = <CLIENT_1_PUBLIC_KEY>
AllowedIPs = 10.80.1.2/32

# Peer 2: Smartphone
[Peer]
PublicKey = <CLIENT_2_PUBLIC_KEY>
AllowedIPs = 10.80.1.3/32
```

**Key-Generierung:**
```bash
# Server-Keys
wg genkey | tee /etc/wireguard/server_privatekey | wg pubkey > /etc/wireguard/server_publickey

# Client-Keys
wg genkey | tee client_privatekey | wg pubkey > client_publickey
```

### Client-Konfiguration

**Client-Config (Beispiel f√ºr Admin-Laptop):**
```ini
[Interface]
PrivateKey = <CLIENT_PRIVATE_KEY>
Address = 10.80.1.2/32
DNS = 1.1.1.1  # Optional: DNS-Server

[Peer]
PublicKey = <SERVER_PUBLIC_KEY>
Endpoint = <JETSON_PUBLIC_IP>:51820
AllowedIPs = 10.80.1.0/24  # Nur Traffic f√ºr VPN-Subnetz √ºber VPN routen
PersistentKeepalive = 25   # F√ºr NAT-Traversal
```

**QR-Code-Generierung:**
```bash
qrencode -t ansiutf8 < client.conf
qrencode -o client-qr.png < client.conf  # F√ºr iOS/Android WireGuard-App
```

### Firewall-Regeln (iptables)

**Strategie:**
- ACCEPT: WireGuard-Port (51820/UDP) von allen IPs (f√ºr VPN-Verbindungen)
- ACCEPT: Ports 80/443 nur von wg0-Interface (VPN)
- ACCEPT: Loopback (lo) f√ºr lokale Tests
- DROP: Ports 80/443 von Public-Interfaces (eth0, wlan0)

**iptables-Script (`/etc/iptables/rules.v4`):**
```bash
*filter
# Default-Policies
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]

# Loopback erlauben
-A INPUT -i lo -j ACCEPT

# Established/Related Verbindungen erlauben
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# WireGuard-Port (51820/UDP) √∂ffentlich
-A INPUT -p udp --dport 51820 -j ACCEPT

# HTTPS (443/TCP) nur von VPN (wg0)
-A INPUT -i wg0 -p tcp --dport 443 -j ACCEPT

# HTTP (80/TCP) nur von VPN (wg0) f√ºr Redirect
-A INPUT -i wg0 -p tcp --dport 80 -j ACCEPT

# HTTPS/HTTP von Public-Interfaces BLOCKEN
-A INPUT -i eth0 -p tcp --dport 443 -j DROP
-A INPUT -i eth0 -p tcp --dport 80 -j DROP
-A INPUT -i wlan0 -p tcp --dport 443 -j DROP
-A INPUT -i wlan0 -p tcp --dport 80 -j DROP

# SSH (22/TCP) nur von VPN (optional, f√ºr Remote-Management)
-A INPUT -i wg0 -p tcp --dport 22 -j ACCEPT

# Prometheus/Grafana nur von VPN (optional, f√ºr Monitoring)
-A INPUT -i wg0 -p tcp --dport 9090 -j ACCEPT
-A INPUT -i wg0 -p tcp --dport 3001 -j ACCEPT

COMMIT
```

**Persistenz-Setup:**
```bash
# iptables-persistent installieren (Debian/Ubuntu)
apt install iptables-persistent

# Regeln speichern
iptables-save > /etc/iptables/rules.v4

# Bei √Ñnderungen: Regeln neu laden
iptables-restore < /etc/iptables/rules.v4
```

### Scripts

**`scripts/add-vpn-client.sh`:**
```bash
#!/bin/bash
# Add WireGuard VPN Client

set -e

CLIENT_NAME=$1
if [ -z "$CLIENT_NAME" ]; then
  echo "Usage: $0 <client-name>"
  exit 1
fi

# Generiere Client-Keys
CLIENT_PRIVATE_KEY=$(wg genkey)
CLIENT_PUBLIC_KEY=$(echo "$CLIENT_PRIVATE_KEY" | wg pubkey)

# N√§chste freie IP finden
LAST_IP=$(wg show wg0 allowed-ips | grep -oP '10\.80\.1\.\K\d+' | sort -n | tail -1)
NEXT_IP=$((LAST_IP + 1))
CLIENT_IP="10.80.1.$NEXT_IP"

# Server-Public-Key auslesen
SERVER_PUBLIC_KEY=$(cat /etc/wireguard/server_publickey)
SERVER_ENDPOINT=${SERVER_PUBLIC_IP:-$(curl -s ifconfig.me 2>/dev/null || echo "")}:51820
if [ -z "${SERVER_ENDPOINT%:51820}" ] || [ "${SERVER_ENDPOINT%:51820}" = "" ]; then
  echo "ERROR: Could not detect public IP. Set SERVER_PUBLIC_IP env variable."
  exit 1
fi

# Peer zu Server-Config hinzuf√ºgen
cat >> /etc/wireguard/wg0.conf <<EOF

# Peer: $CLIENT_NAME
[Peer]
PublicKey = $CLIENT_PUBLIC_KEY
AllowedIPs = $CLIENT_IP/32
EOF

# WireGuard neu laden
wg syncconf wg0 <(wg-quick strip wg0)

# Client-Config generieren
CLIENT_CONF="/tmp/$CLIENT_NAME.conf"
cat > "$CLIENT_CONF" <<EOF
[Interface]
PrivateKey = $CLIENT_PRIVATE_KEY
Address = $CLIENT_IP/32
DNS = 1.1.1.1

[Peer]
PublicKey = $SERVER_PUBLIC_KEY
Endpoint = $SERVER_ENDPOINT
AllowedIPs = 10.80.1.0/24
PersistentKeepalive = 25
EOF

# QR-Code generieren
echo "Client-Konfiguration erstellt: $CLIENT_CONF"
echo "QR-Code:"
qrencode -t ansiutf8 < "$CLIENT_CONF"

echo ""
echo "Client-IP: $CLIENT_IP"
echo "Konfigurationsdatei: $CLIENT_CONF"
echo ""
echo "Importieren Sie die Konfiguration in die WireGuard-App:"
echo "  - macOS/Linux: wg-quick up $CLIENT_CONF"
echo "  - iOS/Android: QR-Code scannen"
```

**`scripts/test-vpn-firewall.sh`:**
```bash
#!/bin/bash
# Test VPN-only Zugriff

set -e

echo "Test 1: VPN-Erreichbarkeit (wg0)"
curl -k -m 5 https://10.80.1.1/api/health && echo "‚úÖ VPN-Zugriff erfolgreich" || echo "‚ùå VPN-Zugriff fehlgeschlagen"

echo ""
echo "Test 2: Public-IP-Blockade (eth0)"
PUBLIC_IP=$(ip -4 addr show eth0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
curl -k -m 5 https://$PUBLIC_IP/api/health && echo "‚ùå Public-Zugriff NICHT geblockt (Sicherheitsl√ºcke!)" || echo "‚úÖ Public-Zugriff geblockt"

echo ""
echo "Test 3: Firewall-Regeln"
iptables -L -n | grep "DROP.*tcp.*443" && echo "‚úÖ Firewall-Regeln aktiv" || echo "‚ùå Firewall-Regeln fehlen"
```

---

## File Locations & Project Structure

**Neue Dateien:**
```
jetson/
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ add-vpn-client.sh           # Client-Setup-Script
‚îÇ   ‚îú‚îÄ‚îÄ test-vpn-firewall.sh        # Firewall-Tests
‚îÇ   ‚îî‚îÄ‚îÄ README.md                   # Script-Dokumentation (erweitert)
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îî‚îÄ‚îÄ deployment/
‚îÇ       ‚îî‚îÄ‚îÄ vpn-setup.md            # VPN-Setup-Dokumentation (neu)
‚îî‚îÄ‚îÄ /etc/wireguard/                 # System-Pfad (nicht im Repo)
    ‚îú‚îÄ‚îÄ wg0.conf                    # WireGuard-Server-Config
    ‚îú‚îÄ‚îÄ server_privatekey           # Server-Private-Key (NICHT committen!)
    ‚îî‚îÄ‚îÄ server_publickey            # Server-Public-Key
```

**Bestehende Dateien (Erweitert):**
- `/etc/iptables/rules.v4` - Firewall-Regeln (persistent)
- `docker-compose.yml` - Keine √Ñnderungen (Caddy-Ports bereits konfiguriert)

**Security-Hinweis:**
- Private-Keys NIEMALS in Git committen!
- `.gitignore` erweitern: `*.privatekey`, `*.conf` (Client-Configs)

---

## Testing

### Test-Strategie

**Test-Framework:** Bash-Scripts + Manual Testing

**Test-Coverage:**
1. WireGuard-Service-Uptime
2. VPN-Erreichbarkeit (HTTPS √ºber wg0)
3. Public-IP-Blockade (HTTPS √ºber eth0/wlan0)
4. Firewall-Persistenz (nach Reboot)
5. Client-Konfiguration (QR-Code, .conf-Import)

### Automated Tests

**Test 1: WireGuard-Service**
```bash
#!/bin/bash
# Test: WireGuard-Service aktiv
systemctl is-active --quiet wg-quick@wg0 && echo "‚úÖ WireGuard aktiv" || exit 1
```

**Test 2: VPN-Erreichbarkeit**
```bash
#!/bin/bash
# Test: HTTPS √ºber VPN erreichbar
curl -k -m 5 https://10.80.1.1/api/health -o /dev/null -s -w "%{http_code}" | grep 200 && echo "‚úÖ VPN-Zugriff OK" || exit 1
```

**Test 3: Public-Blockade**
```bash
#!/bin/bash
# Test: HTTPS √ºber Public-IP geblockt
PUBLIC_IP=$(hostname -I | awk '{print $1}')
curl -k -m 5 https://$PUBLIC_IP/api/health && exit 1 || echo "‚úÖ Public-Zugriff geblockt"
```

**Test 4: Firewall-Persistenz**
```bash
#!/bin/bash
# Test: iptables-Regeln nach Reboot
iptables -L -n | grep -q "DROP.*tcp.*dpt:443" && echo "‚úÖ Firewall-Regeln persistent" || exit 1
```

### Manual Tests

**Test 5: Client-Setup (iOS/Android)**
1. F√ºhre `scripts/add-vpn-client.sh smartphone` aus
2. Scanne QR-Code mit WireGuard-App
3. Aktiviere VPN in der App
4. √ñffne Safari/Chrome: `https://10.80.1.1/`
5. **Erwartetes Ergebnis:** Dashboard l√§dt erfolgreich

**Test 6: Client-Setup (macOS/Linux)**
1. F√ºhre `scripts/add-vpn-client.sh laptop` aus
2. Kopiere `/tmp/laptop.conf` zu `/etc/wireguard/laptop.conf`
3. Aktiviere VPN: `sudo wg-quick up laptop`
4. Teste: `curl -k https://10.80.1.1/api/health`
5. **Erwartetes Ergebnis:** 200 OK

**Test 7: Firewall-Bypass-Versuch**
1. Deaktiviere VPN
2. Ermittle Public-IP: `curl ifconfig.me`
3. Versuche Zugriff: `curl -k https://<public-ip>/api/health`
4. **Erwartetes Ergebnis:** Timeout oder Connection Refused

---

## Integration mit E1.1 & E1.2

### RBAC-Integration (E1.1)

**VPN-Status-Endpoint (nur f√ºr `admin`):**
```typescript
// app/src/routes/vpn.ts
import express from 'express';
import { requireRole } from '../middlewares/rbac';
import { exec } from 'child_process';
import { promisify } from 'util';

const router = express.Router();
const execAsync = promisify(exec);

// GET /api/vpn/status - WireGuard-Status (nur admin)
router.get('/status', requireRole('admin'), async (req, res) => {
  try {
    const { stdout } = await execAsync('wg show wg0 dump');
    const peers = stdout.trim().split('\n').slice(1); // Erste Zeile ist Interface
    
    res.json({
      interface: 'wg0',
      listenPort: 51820,
      peersCount: peers.length,
      peers: peers.map(peer => {
        const [pubkey, , , rxBytes, txBytes] = peer.split('\t');
        return {
          publicKey: pubkey.substring(0, 16) + '...', // Gek√ºrzt f√ºr Security
          rxBytes: parseInt(rxBytes),
          txBytes: parseInt(txBytes)
        };
      })
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch VPN status' });
  }
});

export default router;
```

**Audit-Logging f√ºr VPN-Client-Hinzuf√ºgung:**
- `add-vpn-client.sh` schreibt Audit-Event: `vpn_client_added` mit `client_name`, `client_ip`, `timestamp`

### TLS-Integration (E1.2)

**VPN-Clients nutzen HTTPS:**
- Clients greifen auf `https://10.80.1.1` zu (VPN-Server-IP)
- Caddy terminiert TLS (bereits in E1.2 konfiguriert)
- Self-signed Zertifikat oder step-ca (Phase 1.5)

**Wichtig:** VPN-Clients m√ºssen CA-Zertifikat importieren (gleicher Prozess wie in E1.2 dokumentiert).

**DNS & Zertifikate:**
- VPN-Clients greifen auf Server via IP (10.80.1.1) oder Hostname (arasul.local) zu
- Zertifikat muss f√ºr beide Varianten g√ºltig sein:
  - Self-signed: CN=arasul.local, SAN=IP:10.80.1.1
  - step-ca: `step ca certificate arasul.local cert.pem key.pem --san 10.80.1.1`
- CA-Zertifikat muss auf VPN-Clients importiert werden (siehe E1.2 Dokumentation)

**DNS-Konfiguration (optional):**
- WireGuard-Client-Config kann `DNS = 10.80.1.1` setzen
- Jetson-DNS-Server (z.B. dnsmasq) l√∂st `arasul.local` ‚Üí `10.80.1.1` auf
- **Scope:** Out of MVP (manuell `https://10.80.1.1` f√ºr MVP)

---

## Known Issues & Considerations

1. **WireGuard-Kernel-Modul:**
   - JetPack ‚â•5.x hat WireGuard im Kernel (kein Problem)
   - √Ñltere JetPack-Versionen: `wireguard-dkms` installieren
   - **Test:** `modprobe wireguard && lsmod | grep wireguard`

2. **NAT-Traversal:**
   - Clients hinter NAT ben√∂tigen `PersistentKeepalive = 25`
   - Bei Problemen: Port-Forwarding auf Router pr√ºfen (51820/UDP)

3. **DNS-Leaks:**
   - Clients sollten VPN-DNS nutzen (in Client-Config: `DNS = 1.1.1.1`)
   - Verhindert DNS-Leaks bei Split-Tunnel

4. **Performance:**
   - WireGuard ist hochperformant, aber auf Nano bei >10 Clients m√∂glich Bottleneck
   - **Mitigation:** Prometheus-Monitoring f√ºr VPN-Traffic (Phase 2)

5. **Firewall-Debugging:**
   - Logs aktivieren: `iptables -A INPUT -j LOG --log-prefix "IPT-DROP: "`
   - Logs pr√ºfen: `journalctl -k | grep IPT-DROP`

6. **Key-Management:**
   - Private-Keys M√úSSEN sicher gespeichert werden
   - **Best Practice:** `chmod 600 /etc/wireguard/*.privatekey`
   - Backup-Strategie f√ºr Keys dokumentieren

---

## Dependencies & Prerequisites

- **OS:** Linux (Debian/Ubuntu) mit Kernel ‚â•5.6 (WireGuard integriert)
- **JetPack:** ‚â•5.x (WireGuard-Unterst√ºtzung)
- **Tools:**
  - `wireguard-tools` (`apt install wireguard`)
  - `qrencode` (`apt install qrencode`)
  - `iptables-persistent` (`apt install iptables-persistent`)
- **E1.2:** TLS & Security-Header sollten implementiert sein (VPN-Clients nutzen HTTPS)

---

## Success Metrics

- WireGuard-Service-Uptime: 100% (systemd Auto-Restart)
- VPN-Verbindungen erfolgreich: ‚â•95% (erste Verbindung)
- Public-IP-Blockade: 100% (automatisierte Tests)
- Firewall-Persistenz: 100% (nach Reboot)
- Client-Setup-Zeit: ‚â§5 Minuten (QR-Code-Scan)
- Keine Critical/High CVEs in WireGuard-Tools (w√∂chentlicher Scan via Trivy/Snyk)

---

## Change Log

| Datum | Version | Beschreibung | Autor |
|-------|---------|--------------|-------|
| 2025-10-15 | 1.0 | Story E1.3 erstellt mit vollst√§ndigem Context aus Architektur-Shards | Scrum Master (Claude Sonnet 4.5) |
| 2025-10-15 | 1.1 | Story aktualisiert basierend auf Validierungsbericht: Subnetz-Platzhalter (10.80.1.x), Public-IP-Fallback, AC 6 pr√§zisiert, DNS/Zertifikat-Hinweis, NAT-Traversal-Risiko, CVE-Monitoring | Scrum Master (Claude Sonnet 4.5) |

---

## Status

**Status:** üìù **DRAFT** (Ready for Implementation)

**Next Steps:**
1. Review durch Tech Lead
2. Threat-Model-Checkliste durchgehen (Shard 11)
3. Implementation starten (Task 1: WireGuard-Installation)
4. Tests durchf√ºhren
5. QA-Review

---

**Version:** 1.1  
**Datum:** 15. Oktober 2025  
**Erstellt von:** Scrum Master (Claude Sonnet 4.5)  
**Aktualisiert:** 15. Oktober 2025 (Validierungsbericht-Empfehlungen implementiert)
